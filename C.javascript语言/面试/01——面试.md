

## 01. 基本数据类型
String; Number; Boolean; Null; Undefined 




## 02. 内置数据对象
Object是所有对象的父对象
封装对象：Object; String; Array; Boolean; Number
其他对象：Function; arguments; Math; Date; RegExp; Error




## 02.1 换肤功能
通过改变link标签的href，来实现换肤
```js
<link rel="stylesheet" id="myCss" href="./css/index1.css" >    

document.getElementById("myCss").href = './css/index2.css'
```




## 03. js写入cookie
```js
function writeCookie(csspath) {    
  var today = new Date();    
  var expires = new Date();    
  expires.setTime(today.getTime() + 1000 * 60 * 60 * 24 * 30); //有效期为30天    
  var str = "cssPath=" + csspath + ";expires=" + expires.toGMTString() + ";";    
  document.cookie = str;    
}   
```




## 04. js读取cookie
```js
function readCookie(cookieName) {    
  var search = cookieName + "=";    
  if (document.cookie.length > 0) {    
    var offset = document.cookie.indexOf(search);    
    if (offset != -1) {    
      offset += search.length;    
      end = document.cookie.indexOf(";", offset);    
      if (end == -1) {    
        end = document.cookie.length;    
      }    
      return encodeURI(document.cookie.substring(offset, end));   
    }    
  }    
}    
readCookie('token_uid')
```




## 05. 编码格式
- 为什么要进行url编码
因为服务器解析是根据&和=来解析的，所以对于&和=需要转义，
url的编码格式采用的是ASCII码，而不是Unicode。对于非ASCII码的就需要转义

- 编码的3个方法
escape
encodeURI：           !#$&'()*+,/:;=?@-._~0-9a-zA-Z
encodeURIComponent：  !'()*-._~0-9a-zA-Z

第1个已经被废弃，所以现在使用后面2个



## 06. 媒体查询
```html
<!-- link元素中的CSS媒体查询 -->
<link rel="stylesheet" media="(max-width: 800px)" href="example.css" />

<!-- 样式表中的CSS媒体查询 -->
<style>
@media tv and (min-width: 700px) and (orientation: landscape) {
  .facet_sidebar {
    display: none;
  }
}
</style>
```



## 07. this
函数中，this通常是一个隐藏的参数；
函数外，this指的是所在的上下文；
Node中，this指向的是module.exports



## 08. 介绍一下原型和原型链
每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。

关系：instance.constructor.prototype = instance.__proto__
特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本，当我们修改原型时，与之相关的对象也会继承这一改变。
当我们需要一个属性时，JavaScript引擎会先看当前对象中是否有这个属性，如果没有的话，就会查找它的prototype对象是否有这个属性，如此递推下去，一致检索到Object内建对象。




## 09. 事件封装
```js
Event = {
    //页面加载完成后
    readyEvent: function(fn) {
      if (fn == null) {
        fn = document;
      } 
      var oldonload = window.onload; 
      if (typeof window.onload != 'function') {
        window.onload = fn; 
      }else{
        window.onload = function() { 
          oldonload(); 
          fn();
        }; 
      }
    }, 
    //视能力分别使用 demo0 || demo1 || IE 方式来绑定事件 
    //参数：操作的元素，事件名称，事件处理程序 
    addEvent: function(element,type,handler) { 
      if (element.addEventListener) { //事件类型、需要执行的函数、是否捕捉   
        element.addEventListener(type,handler,false); 
      } else if (element.attachEvent) { 
        element.attachEvent('on' + type, function() {
          handler.call(element);
        }); 
      } else { 
        element['on' + type] = handler; 
      }
    }, 
    //移除事件 
    removeEvent: function(element,type,handler) {
      if (element.removeEventListener) {
        element.removeEventListener(type,handler,false); 
      } else if (element.datachEvent) { 
        element.detachEvent('on' + type,handler); 
      } else{
        element['on' + type] = null;
      }
    },
    //阻止事件（主要是事件冒泡，因为IE不支持事件捕获） 
    stopPropagation: function(ev) { 
      if (ev.stopPropagation) { 
        ev.stopPropagation(); 
      }else { 
        ev.cancelBubble = true;
      }
    },
    //取消事件的默认行为
    preventDefault: function(event) {
      if (event.preventDefault) { 
        event.preventDefault(); 
      }else{
        event.returnValue = false; 
      }
    }, 
    //获取事件目标 
    getTarget: function(event) { 
      return event.target || event.srcElemnt; 
    },
    //获取event对象的引用，取到事件的所有信息，确保随时能使用event； 
    getEvent: function(e) { 
      var ev = e || window.event;
      if (!ev) { 
        var c = this.getEvent.caller; 
        while(c) { 
          ev = c.argument[0]; 
          if (ev && Event == ev.constructor) {
            break; 
          } 
          c = c.caller; 
        } 
      } 
      return ev; 
    }
};
```




## 10. 手写XMLHttpRequest fetch
- fetch的优点
更底层的请求api，对于404/500这些请求也算作正常的返回，能够更方便区分业务异常和其他基础设置erro
```js

```