# react-redux source code

## 1.Provider
store保存了状态
并且store被provider作为context传递
```js
class Provider extends Component {
  getChildContext() {
    return { 
      'store': this.store, 
      'storeKey': null 
    }
  }
  constructor(props, context) {
    super(props, context)
    this.store = props.store;
  }
  render() {
    return Children.only(this.props.children)
  }
}
```
```html
<Provider store={store}>
  <App />
</Provider>
```



## 2.App
其实就是定义了一个Todo组件,生成state/action的方法
```js
class Todo extends React.Component {
  constructor(props) {
    super(props);
    /** 此处props的结构,是通过mapState/DispatchToProps计算出来的
      {
        todos: Array[1], 
        actions: Object
      }
    */
  }
}

const mapStateToProps = state => ({
  todos: state.todos
})
const mapDispatchToProps = dispatch => ({
    actions: bindActionCreators(TodoActions, dispatch)
})

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(Todo)
```




## 3.connect
connect只时一个简单的包装,做了如下处理
- a.将一些参数通过闭包保存了下来
- b.包装了两个map方法为: initMapStateToProps/initMapDispatchToProps
```js
export function createConnect({
  connectHOC = connectAdvanced,
  mapStateToPropsFactories = defaultMapStateToPropsFactories,
  mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories,
  selectorFactory = defaultSelectorFactory
} = {}) {
  return function connect(
    mapStateToProps,
    mapDispatchToProps,
  ) {
    const initMapStateToProps    = match(mapStateToProps, mapStateToPropsFactories)
    const initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories)

    return connectHOC(selectorFactory, {
      initMapStateToProps,
      initMapDispatchToProps
    })
  }
}

export default createConnect()
```






## 4.match(state/dispatch, factory)
match方法就是一个循环,调用factory中的方法,如果都没返回就报错
---





## 5.mapStateToPropsFactories/mapDispatchToPropsFactories
看看这些方法都有什么
```js
/**
 * mapStateToPropsFactories: function | null
 */
export function whenMapStateToPropsIsFunction(mapStateToProps) {
  return (typeof mapStateToProps === 'function')
    ? wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps')
    : undefined
}
export function whenMapStateToPropsIsMissing(mapStateToProps) {
  return (!mapStateToProps)
    ? wrapMapToPropsConstant(() => ({}))
    : undefined
}


/**
 * mapDispatchToPropsFactories: function | null | object
 */ 
export function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
  return (typeof mapDispatchToProps === 'function')
    ? wrapMapToPropsFunc(mapDispatchToProps, 'mapDispatchToProps')
    : undefined
}
export function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
  return (!mapDispatchToProps)
    ? wrapMapToPropsConstant(dispatch => ({ dispatch }))
    : undefined
}
export function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
  return (mapDispatchToProps && typeof mapDispatchToProps === 'object')
    ? wrapMapToPropsConstant(dispatch => bindActionCreators(mapDispatchToProps, dispatch))
    : undefined
}
```






## 6.wrapMapToPropsFunc
这里先知考虑都是function类型,调用wrapMapToPropsFunc的方法,可以先不看内容
> 
> 两个mapToProps此时已经被保存在了闭包里,由各自的initProxySelector维护
>
```js
/**
 * mapToProps其实就是 mapStateToProps | mapDispatchToProps
 */ 
export function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, { displayName }) {
    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps
        ? proxy.mapToProps(stateOrDispatch, ownProps)
        : proxy.mapToProps(stateOrDispatch)
    }

    // allow detectFactoryAndVerify to get ownProps
    proxy.dependsOnOwnProps = true

    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps)
      let props = proxy(stateOrDispatch, ownProps)

      if (typeof props === 'function') {
        proxy.mapToProps = props
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props)
        props = proxy(stateOrDispatch, ownProps)
      }

      if (process.env.NODE_ENV !== 'production') 
        verifyPlainObject(props, displayName, methodName)

      return props
    }

    return proxy
  }
}
```



## 7.至此上面代码调用完成,看看执行结果
调用的结果如下
```js
const initMapStateToProps    = function initProxySelector(dispatch, { displayName }){}
const initMapDispatchToProps = function initProxySelector(dispatch, { displayName }){}

return connectHOC(selectorFactory, {
  initMapStateToProps,
  initMapDispatchToProps
})
```



## 07.调用connectHOC
调用的结果如下
```js
export default function connectAdvanced(
  selectorFactory,
  {
    initMapStateToProps,
    initMapDispatchToProps
  }
) {

  const contextTypes = {
    store: storeShape,
    storeSubscription: subscriptionShape,
  }
  const childContextTypes = {
    storeSubscription: subscriptionShape,
  }

  return function wrapWithConnect(WrappedComponent){
    //...
  }
}
```




## 08.wrapWithConnect
返回的是App组件, 能够访问到Provider的context.store
```js
return function wrapWithConnect(WrappedComponent) {

  const selectorFactoryOptions = {
    initMapStateToProps,
    initMapDispatchToProps
  }

  class Connect extends Component {
    constructor(props, context) {
      super(props, context)
      this.version = version
      this.state = {}
      this.renderCount = 0
      this.store = props[storeKey] || context[storeKey]
      this.propsMode = Boolean(props[storeKey])
      this.setWrappedInstance = this.setWrappedInstance.bind(this)
      this.initSelector()
      this.initSubscription()
    }

    getChildContext() {
      const subscription = this.propsMode ? null : this.subscription
      return { 
        storeSubscription: subscription || this.context[subscriptionKey] 
      }
    }

    componentDidMount() {
      if (!shouldHandleStateChanges) return

      this.subscription.trySubscribe()
      this.selector.run(this.props)
      if (this.selector.shouldComponentUpdate) this.forceUpdate()
    }

    componentWillReceiveProps(nextProps) {
      this.selector.run(nextProps)
    }

    shouldComponentUpdate() {
      return this.selector.shouldComponentUpdate
    }

    componentWillUnmount() {
      if (this.subscription) this.subscription.tryUnsubscribe()
      this.subscription = null
      this.notifyNestedSubs = noop
      this.store = null
      this.selector.run = noop
      this.selector.shouldComponentUpdate = false
    }

    getWrappedInstance() {
      invariant(withRef,
        `To access the wrapped instance, you need to specify ` +
        `{ withRef: true } in the options argument of the ${methodName}() call.`
      )
      return this.wrappedInstance
    }

    setWrappedInstance(ref) {
      this.wrappedInstance = ref
    }

    initSelector() {
      const sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions)

      this.selector = makeSelectorStateful(sourceSelector, this.store)
      this.selector.run(this.props)
    }

    initSubscription() {
      if (!shouldHandleStateChanges) return

      const parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey]
      this.subscription = new Subscription(this.store, parentSub, this.onStateChange.bind(this))

      //  第一次 this.subscription = new Subscription(this.store, this.context, this.onStateChange.bind(this))
      //  通知嵌套的订阅，notifyNestedSubs
      this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription)
    }

    onStateChange() {
      this.selector.run(this.props)
      if (!this.selector.shouldComponentUpdate) {
        this.notifyNestedSubs()
      } else {
        this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate
        this.setState(dummyState)
      }
    }

    notifyNestedSubsOnComponentDidUpdate() {

      this.componentDidUpdate = undefined
      this.notifyNestedSubs()
    }

    isSubscribed() {
      return Boolean(this.subscription) && this.subscription.isSubscribed()
    }

    addExtraProps(props) {
      if (!withRef && !renderCountProp && !(this.propsMode && this.subscription)) 
        return props

      const withExtras = { ...props }

      if (withRef) 
        withExtras.ref = this.setWrappedInstance

      if (renderCountProp) 
        withExtras[renderCountProp] = this.renderCount++

      if (this.propsMode && this.subscription) 
        withExtras[subscriptionKey] = this.subscription

      return withExtras
    }

    render() {
      const selector = this.selector
      selector.shouldComponentUpdate = false

      if (selector.error) {
        throw selector.error
      } else {
        return createElement(WrappedComponent, this.addExtraProps(selector.props))
      }
    }
    
  }

  Connect.WrappedComponent = WrappedComponent
  Connect.displayName = displayName
  Connect.childContextTypes = childContextTypes
  Connect.contextTypes = contextTypes
  Connect.propTypes = contextTypes

  return hoistStatics(Connect, WrappedComponent)

}
```



## 09.this.initSelector()
调用的结果如下
```js
initSelector() {
  //  这里注意一下, 传入了selectorFactoryOptions, 即
  const sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions)
  this.selector = makeSelectorStateful(sourceSelector, this.store)
  this.selector.run(this.props)
}
```



## 10.selectorFactory
根据option.pure调用不同的方法, 默认为true
```js
export default function finalPropsSelectorFactory(dispatch, {
  initMapStateToProps,
  initMapDispatchToProps
  ...option
}) {
  const mapStateToProps    = initMapStateToProps(dispatch, options)
  const mapDispatchToProps = initMapDispatchToProps(dispatch, options)

  const selectorFactory = options.pure
    ? pureFinalPropsSelectorFactory
    : impureFinalPropsSelectorFactory

  return selectorFactory(
    mapStateToProps,
    mapDispatchToProps,
    mergeProps,
    dispatch,
    options
  )
}
```


## 11.initMapStateToProps/initMapDispatchToProps
根据option.pure调用不同的方法, 默认为true
```js
export default function finalPropsSelectorFactory(dispatch, {
  initMapStateToProps,
  initMapDispatchToProps
  ...option
}) {
  const mapStateToProps    = initProxySelector(dispatch, options)
  const mapDispatchToProps = initProxySelector(dispatch, options)
  //...
}
```




## 12.initProxySelector
调用的结果如下, 入参我还原了一下
```js
function initProxySelector(dispatch, { displayName }) {

  const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
    return proxy.dependsOnOwnProps
      ? proxy.mapToProps(stateOrDispatch, ownProps)
      : proxy.mapToProps(stateOrDispatch)
  }

  proxy.dependsOnOwnProps = true

  proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
    proxy.mapToProps = mapToProps
    proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps)
    let props = proxy(stateOrDispatch, ownProps)

    if (typeof props === 'function') {
      proxy.mapToProps = props
      proxy.dependsOnOwnProps = getDependsOnOwnProps(props)
      props = proxy(stateOrDispatch, ownProps)
    }

    if (process.env.NODE_ENV !== 'production') 
      verifyPlainObject(props, displayName, methodName)

    return props
  }

  return proxy
}
```



## 13.selectorFactory
根据12的结果就是
```js
export default function finalPropsSelectorFactory(dispatch, {
  initMapStateToProps,
  initMapDispatchToProps
  ...option
}) {
  const mapStateToProps    = proxy
  const mapDispatchToProps = proxy

  const selectorFactory = options.pure
    ? pureFinalPropsSelectorFactory
    : impureFinalPropsSelectorFactory

  return selectorFactory(
    proxy(mapStateToProps),
    proxy(mapDispatchToProps),
    dispatch
  )
}
```



## 14.pureFinalPropsSelectorFactory
继续调用
```js
export function pureFinalPropsSelectorFactory(
  mapStateToProps,
  mapDispatchToProps,
  dispatch
) {
  let hasRunAtLeastOnce = false
  let state
  let ownProps
  let stateProps
  let dispatchProps
  let mergedProps

  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState
    ownProps = firstOwnProps
    stateProps = mapStateToProps(state, ownProps)
    dispatchProps = mapDispatchToProps(dispatch, ownProps)
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
    hasRunAtLeastOnce = true
    return mergedProps
  }

  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps)

    if (mapDispatchToProps.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps(dispatch, ownProps)

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
    return mergedProps
  }

  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps)
      stateProps = mapStateToProps(state, ownProps)

    if (mapDispatchToProps.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps(dispatch, ownProps)

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
    return mergedProps
  }

  function handleNewState() {
    const nextStateProps = mapStateToProps(state, ownProps)
    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps)
    stateProps = nextStateProps
    
    if (statePropsChanged)
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps)

    return mergedProps
  }

  function handleSubsequentCalls(nextState, nextOwnProps) {
    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps)
    const stateChanged = !areStatesEqual(nextState, state)
    state = nextState
    ownProps = nextOwnProps

    if (propsChanged && stateChanged) return handleNewPropsAndNewState()
    if (propsChanged) return handleNewProps()
    if (stateChanged) return handleNewState()
    return mergedProps
  }

  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce
      ? handleSubsequentCalls(nextState, nextOwnProps)
      : handleFirstCall(nextState, nextOwnProps)
  }
}

```





## 15.initSelector
再返回上去,结果如下,接着调用makeSelectorStateful
```js
initSelector() {
  //  结果即为
  const sourceSelector = function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce
      ? handleSubsequentCalls(nextState, nextOwnProps)
      : handleFirstCall(nextState, nextOwnProps)
  }
  //  
  this.selector = makeSelectorStateful(sourceSelector, this.store)
  this.selector.run(this.props)
}
```




## 16.makeSelectorStateful
传入sourceSelector和store, 返回selector
```js
function makeSelectorStateful(sourceSelector, store) {
  const selector = {
    run: function runComponentSelector(props) {
      try {
        const nextProps = sourceSelector(store.getState(), props)
        if (nextProps !== selector.props || selector.error) {
          selector.shouldComponentUpdate = true
          selector.props = nextProps
          selector.error = null
        }
      } catch (error) {
        selector.shouldComponentUpdate = true
        selector.error = error
      }
    }
  }
  return selector
}

this.selector.run(this.props)
```




## 17.sourceSelector
可以发现pureFinalPropsSelectorFactory中通过闭包维护了state和props

handleNewProps/handleNewState合并了一下数据
```js
// 后续的调用, 会做比较然后返回, 没更新就返回mergedProps, 要更新就返回调用结果
function handleSubsequentCalls(nextState, nextOwnProps) {
  const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps)
  const stateChanged = !areStatesEqual(nextState, state)
  state = nextState
  ownProps = nextOwnProps

  if (propsChanged && stateChanged) return handleNewPropsAndNewState()
  if (propsChanged) return handleNewProps()
  if (stateChanged) return handleNewState()
  return mergedProps
}

//  第一次调用的时候,只是对状态做比较
function handleFirstCall(firstState, firstOwnProps) {
  state = firstState
  ownProps = firstOwnProps
  stateProps = mapStateToProps(state, ownProps)
  dispatchProps = mapDispatchToProps(dispatch, ownProps)
  mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
  hasRunAtLeastOnce = true
  return mergedProps
}
```






## 17.handleNewProps
最终结果就是selector被设置了一下属性值, 是否需要更新和props
```js
this.selector.run(this.props)
```



## 18.initSubscription
传入了store, parentSub, onStateChange
```js
initSubscription() {
  if (!shouldHandleStateChanges) return

  const parentSub = (this.propsMode ? this.props : this.context)['storeSubscription']
  this.subscription = new Subscription(this.store, parentSub, this.onStateChange.bind(this))

  //  第一次 this.subscription = new Subscription(this.store, this.context, this.onStateChange.bind(this))
  //  通知嵌套的订阅，notifyNestedSubs
  this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription)
}
```




## 19.listeners
listeners是订阅模型保存订阅内容的地方
```js
function createListenerCollection() {
  // the current/next pattern is copied from redux's createStore code.
  // TODO: refactor+expose that code to be reusable here?
  let current = []
  let next = []

  return {
    clear() {
      next = CLEARED
      current = CLEARED
    },

    notify() {
      const listeners = current = next
      for (let i = 0; i < listeners.length; i++) {
        listeners[i]()
      }
    },

    get() {
      return next
    },

    subscribe(listener) {
      let isSubscribed = true
      if (next === current) next = current.slice()
      next.push(listener)

      return function unsubscribe() {
        if (!isSubscribed || current === CLEARED) return
        isSubscribed = false

        if (next === current) next = current.slice()
        next.splice(next.indexOf(listener), 1)
      }
    }
  }
}
```





## 20.new Subscription
新建订阅模型
```js
export default class Subscription {
  
  constructor(store, parentSub, onStateChange) {
    this.store = store
    this.parentSub = parentSub
    this.onStateChange = onStateChange
    this.unsubscribe = null
    this.listeners = nullListeners
  }

  //订阅
  addNestedSub(listener) {
    this.trySubscribe()
    return this.listeners.subscribe(listener)
  }

  //通知,调用了isteners里面的方法
  notifyNestedSubs() {
    this.listeners.notify()
  }

  //判断是否订阅
  isSubscribed() {
    return Boolean(this.unsubscribe)
  }

  //初次绑定, 跟redux中store的解绑类似, 解除监听只要调用监听返回的函数; 同时创建listeners
  trySubscribe() {
    if (!this.unsubscribe) {
      this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.onStateChange) : this.store.subscribe(this.onStateChange)
      //  第一次：this.store.subscribe(this.onStateChange)
      this.listeners = createListenerCollection()
    }
  }

  //解除订阅
  tryUnsubscribe() {
    if (this.unsubscribe) {
      this.unsubscribe()
      this.unsubscribe = null
      this.listeners.clear()
      this.listeners = nullListeners
    }
  }
}
```





## 21.接着就是connect的生命周期了
我们针对第一次调用说明一下
- 调用this.subscription.trySubscribe(); redux的store就会订阅onStateChange函数; 当store里面的state改变就会调用onStateChange;
- 
```js
componentDidMount() {
  if (!shouldHandleStateChanges) return
  this.subscription.trySubscribe()
  this.selector.run(this.props)
  if (this.selector.shouldComponentUpdate) this.forceUpdate()
}

onStateChange() {
  // App上的, 不传就为{}
  this.selector.run(this.props)
  if (!this.selector.shouldComponentUpdate) {
    //不需要更新的时候
    this.notifyNestedSubs()
  } else {
    //需要更新的时候,就等到更新完成了再通知
    this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate
    //这里状态改变, 组件重新刷新, 重新再走一遍流程, componentDidUpdate就会调用上面的方法
    this.setState(dummyState)
  }
}

componentWillUnmount() {
  if (this.subscription) this.subscription.tryUnsubscribe()
  this.subscription = null
  this.notifyNestedSubs = noop
  this.store = null
  this.selector.run = noop
  this.selector.shouldComponentUpdate = false
}

componentWillReceiveProps(nextProps) {
  this.selector.run(nextProps)
}

notifyNestedSubsOnComponentDidUpdate() {
  this.componentDidUpdate = undefined
  this.notifyNestedSubs()
}


```