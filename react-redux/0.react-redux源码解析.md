# react-redux source code

## 01.Provider
store保存了状态, 并且store被provider作为context传递, 可知App里面访问到的store就是redux中的store
```js
class Provider extends Component {
  getChildContext() {
    return { 
      'store': this.store, 
      'storeKey': null 
    }
  }
  constructor(props, context) {
    super(props, context)
    this.store = props.store;
  }
  render() {
    return Children.only(this.props.children)
  }
}
```
```html
<Provider store={store}>
  <App />
</Provider>
```

----





## 02.connect
这里对state, dispatch进行了预处理, 然后跟着selector一起传入了connectAdvanced
```js
export function createConnect({
  connectHOC = connectAdvanced,
  mapStateToPropsFactories = defaultMapStateToPropsFactories,
  mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories,
  selectorFactory = defaultSelectorFactory
} = {}) {
  return function connect(
    mapStateToProps,
    mapDispatchToProps,
  ) {
    const initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories)
    const initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories)

    return connectHOC(selectorFactory, {
      initMapStateToProps,
      initMapDispatchToProps
    })
  }
}

export default createConnect()
```

----






## 03.match(state/dispatch, factory)
根据state/dispatch类型调用factory中的方法并返回
---





## 04.mapStateToPropsFactories/mapDispatchToPropsFactories
先看对state/dispatch的处理, 类型有: function/null
```js

//  mapStateToPropsFactories
export function whenMapStateToPropsIsFunction(mapStateToProps) {
  return (typeof mapStateToProps === 'function')
    ? wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps')
    : undefined
}

export function whenMapStateToPropsIsMissing(mapStateToProps) {
  return (!mapStateToProps)
    ? wrapMapToPropsConstant(() => ({}))
    : undefined
}

export default [
  whenMapStateToPropsIsFunction,
  whenMapStateToPropsIsMissing
]

//  mapDispatchToPropsFactories
export function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
  return (typeof mapDispatchToProps === 'function')
    ? wrapMapToPropsFunc(mapDispatchToProps, 'mapDispatchToProps')
    : undefined
}

export function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
  return (!mapDispatchToProps)
    ? wrapMapToPropsConstant(dispatch => ({ dispatch }))
    : undefined
}

export function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
  return (mapDispatchToProps && typeof mapDispatchToProps === 'object')
    ? wrapMapToPropsConstant(dispatch => bindActionCreators(mapDispatchToProps, dispatch))
    : undefined
}

export default [
  whenMapDispatchToPropsIsFunction,
  whenMapDispatchToPropsIsMissing,
  whenMapDispatchToPropsIsObject
]

```
---


## 05.wrapMapToPropsFunc
这里先知考虑都是function类型,调用wrapMapToPropsFunc的方法, initProxySelector内方法待解析
```js
export function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, { displayName }) {
    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps
        ? proxy.mapToProps(stateOrDispatch, ownProps)
        : proxy.mapToProps(stateOrDispatch)
    }

    // allow detectFactoryAndVerify to get ownProps
    proxy.dependsOnOwnProps = true

    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps)
      let props = proxy(stateOrDispatch, ownProps)

      if (typeof props === 'function') {
        proxy.mapToProps = props
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props)
        props = proxy(stateOrDispatch, ownProps)
      }

      if (process.env.NODE_ENV !== 'production') 
        verifyPlainObject(props, displayName, methodName)

      return props
    }

    return proxy
  }
}
```



## 06.至此第一次调用完成, 然后
调用的结果如下
```js
const initMapStateToProps    = function initProxySelector(dispatch, { displayName }){}
const initMapDispatchToProps = function initProxySelector(dispatch, { displayName }){}

return connectHOC(selectorFactory, {
  initMapStateToProps,
  initMapDispatchToProps
})
```



## 07.调用connectHOC
调用的结果如下
```js
export default function connectAdvanced(
  selectorFactory,
  {
    initMapStateToProps,
    initMapDispatchToProps
  }
) {

  const contextTypes = {
    store: storeShape,
    storeSubscription: subscriptionShape,
  }
  const childContextTypes = {
    storeSubscription: subscriptionShape,
  }

  return function wrapWithConnect(WrappedComponent){
    //...
  }
}
```




## 08.wrapWithConnect
返回的是App组件, 能够访问到Provider的context.store
```js
return function wrapWithConnect(WrappedComponent) {

  const selectorFactoryOptions = {
    initMapStateToProps,
    initMapDispatchToProps
  }

  class Connect extends Component {
    constructor(props, context) {
      super(props, context)
      this.version = version
      this.state = {}
      this.renderCount = 0
      this.store = props[storeKey] || context[storeKey]
      this.propsMode = Boolean(props[storeKey])
      this.setWrappedInstance = this.setWrappedInstance.bind(this)
      this.initSelector()
      this.initSubscription()
    }

    getChildContext() {
      const subscription = this.propsMode ? null : this.subscription
      return { 
        storeSubscription: subscription || this.context[subscriptionKey] 
      }
    }

    componentDidMount() {
      if (!shouldHandleStateChanges) return

      this.subscription.trySubscribe()
      this.selector.run(this.props)
      if (this.selector.shouldComponentUpdate) this.forceUpdate()
    }

    componentWillReceiveProps(nextProps) {
      this.selector.run(nextProps)
    }

    shouldComponentUpdate() {
      return this.selector.shouldComponentUpdate
    }

    componentWillUnmount() {
      if (this.subscription) this.subscription.tryUnsubscribe()
      this.subscription = null
      this.notifyNestedSubs = noop
      this.store = null
      this.selector.run = noop
      this.selector.shouldComponentUpdate = false
    }

    getWrappedInstance() {
      invariant(withRef,
        `To access the wrapped instance, you need to specify ` +
        `{ withRef: true } in the options argument of the ${methodName}() call.`
      )
      return this.wrappedInstance
    }

    setWrappedInstance(ref) {
      this.wrappedInstance = ref
    }

    initSelector() {
      const sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions)

      this.selector = makeSelectorStateful(sourceSelector, this.store)
      this.selector.run(this.props)
    }

    initSubscription() {
      if (!shouldHandleStateChanges) return

      const parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey]
      this.subscription = new Subscription(this.store, parentSub, this.onStateChange.bind(this))

      //  第一次 this.subscription = new Subscription(this.store, this.context, this.onStateChange.bind(this))
      //  通知嵌套的订阅，notifyNestedSubs
      this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription)
    }

    onStateChange() {
      this.selector.run(this.props)
      if (!this.selector.shouldComponentUpdate) {
        this.notifyNestedSubs()
      } else {
        this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate
        this.setState(dummyState)
      }
    }

    notifyNestedSubsOnComponentDidUpdate() {

      this.componentDidUpdate = undefined
      this.notifyNestedSubs()
    }

    isSubscribed() {
      return Boolean(this.subscription) && this.subscription.isSubscribed()
    }

    addExtraProps(props) {
      if (!withRef && !renderCountProp && !(this.propsMode && this.subscription)) 
        return props

      const withExtras = { ...props }

      if (withRef) 
        withExtras.ref = this.setWrappedInstance

      if (renderCountProp) 
        withExtras[renderCountProp] = this.renderCount++

      if (this.propsMode && this.subscription) 
        withExtras[subscriptionKey] = this.subscription

      return withExtras
    }

    render() {
      const selector = this.selector
      selector.shouldComponentUpdate = false

      if (selector.error) {
        throw selector.error
      } else {
        return createElement(WrappedComponent, this.addExtraProps(selector.props))
      }
    }
    
  }

  Connect.WrappedComponent = WrappedComponent
  Connect.displayName = displayName
  Connect.childContextTypes = childContextTypes
  Connect.contextTypes = contextTypes
  Connect.propTypes = contextTypes

  return hoistStatics(Connect, WrappedComponent)

}
```



## 09.this.initSelector()
调用的结果如下
```js
initSelector() {
  //  这里注意一下, 传入了selectorFactoryOptions, 即
  const sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions)
  this.selector = makeSelectorStateful(sourceSelector, this.store)
  this.selector.run(this.props)
}
```



## 10.selectorFactory
根据option.pure调用不同的方法, 默认为true
```js
export default function finalPropsSelectorFactory(dispatch, {
  initMapStateToProps,
  initMapDispatchToProps
  ...option
}) {
  const mapStateToProps    = initMapStateToProps(dispatch, options)
  const mapDispatchToProps = initMapDispatchToProps(dispatch, options)

  const selectorFactory = options.pure
    ? pureFinalPropsSelectorFactory
    : impureFinalPropsSelectorFactory

  return selectorFactory(
    mapStateToProps,
    mapDispatchToProps,
    mergeProps,
    dispatch,
    options
  )
}
```


## 11.initMapStateToProps/initMapDispatchToProps
根据option.pure调用不同的方法, 默认为true
```js
export default function finalPropsSelectorFactory(dispatch, {
  initMapStateToProps,
  initMapDispatchToProps
  ...option
}) {
  const mapStateToProps    = initProxySelector(dispatch, options)
  const mapDispatchToProps = initProxySelector(dispatch, options)
  //...
}
```




## 12.initProxySelector
调用的结果如下, 入参我还原了一下
```js
function initProxySelector(dispatch, { displayName }) {

  const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
    return proxy.dependsOnOwnProps
      ? proxy.mapToProps(stateOrDispatch, ownProps)
      : proxy.mapToProps(stateOrDispatch)
  }

  proxy.dependsOnOwnProps = true

  proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
    proxy.mapToProps = mapToProps
    proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps)
    let props = proxy(stateOrDispatch, ownProps)

    if (typeof props === 'function') {
      proxy.mapToProps = props
      proxy.dependsOnOwnProps = getDependsOnOwnProps(props)
      props = proxy(stateOrDispatch, ownProps)
    }

    if (process.env.NODE_ENV !== 'production') 
      verifyPlainObject(props, displayName, methodName)

    return props
  }

  return proxy
}
```



## 13.selectorFactory
根据12的结果就是
```js
export default function finalPropsSelectorFactory(dispatch, {
  initMapStateToProps,
  initMapDispatchToProps
  ...option
}) {
  const mapStateToProps    = proxy
  const mapDispatchToProps = proxy

  const selectorFactory = options.pure
    ? pureFinalPropsSelectorFactory
    : impureFinalPropsSelectorFactory

  return selectorFactory(
    mapStateToProps,
    mapDispatchToProps,
    mergeProps,
    dispatch,
    options
  )
}
```



## 14.pureFinalPropsSelectorFactory
继续调用
```js
export function pureFinalPropsSelectorFactory(
  proxy(mapStateToProps),
  proxy(mapDispatchToProps),
  dispatch
) {
  let hasRunAtLeastOnce = false
  let state
  let ownProps
  let stateProps
  let dispatchProps
  let mergedProps

  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState
    ownProps = firstOwnProps
    stateProps = mapStateToProps(state, ownProps)
    dispatchProps = mapDispatchToProps(dispatch, ownProps)
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
    hasRunAtLeastOnce = true
    return mergedProps
  }

  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps)

    if (mapDispatchToProps.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps(dispatch, ownProps)

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
    return mergedProps
  }

  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps)
      stateProps = mapStateToProps(state, ownProps)

    if (mapDispatchToProps.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps(dispatch, ownProps)

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
    return mergedProps
  }

  function handleNewState() {
    const nextStateProps = mapStateToProps(state, ownProps)
    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps)
    stateProps = nextStateProps
    
    if (statePropsChanged)
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps)

    return mergedProps
  }

  function handleSubsequentCalls(nextState, nextOwnProps) {
    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps)
    const stateChanged = !areStatesEqual(nextState, state)
    state = nextState
    ownProps = nextOwnProps

    if (propsChanged && stateChanged) return handleNewPropsAndNewState()
    if (propsChanged) return handleNewProps()
    if (stateChanged) return handleNewState()
    return mergedProps
  }

  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce
      ? handleSubsequentCalls(nextState, nextOwnProps)
      : handleFirstCall(nextState, nextOwnProps)
  }
}

```