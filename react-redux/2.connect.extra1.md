# connect流程
这里默认mapStateToProps，mapDispatchToProps都是function
```js
export default connect(
  mapStateToProps,
  mapDispatchToProps
)(Todo)
```

### 1. 调用connect，connect/connect.js
介绍下面结构，用到了解构赋值，是一个科里化函数，={}这个不是多余的，否则当()传空的时候，就会报错
```js
var otherFunction = function(){ console.log('finished') }
export function createConnect( {a = 10}={} ) {
  console.log(arguments)
  return function connect( {pure = true, connectHOC=otherFunction}={} ) {
    return connectHOC()
  }
}

createConnect()()
//  finished
```
其实我们调用的就是：connectHOC()

### 2.分析connect里面的方法
```js
export function createConnect({
  /*  一些准备好的工具函数，在connect中调用  */
  connectHOC = connectAdvanced,
  mapStateToPropsFactories = defaultMapStateToPropsFactories,
  mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories,
  mergePropsFactories = defaultMergePropsFactories,
  selectorFactory = defaultSelectorFactory
} = {}) {

  return function connect(
    mapStateToProps,
    mapDispatchToProps,
    mergeProps,
    /*...*/
  ) {
    
    const initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps')
    const initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps')
    const initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps')

    return connectHOC(selectorFactory, {
      // used in error messages
      methodName: 'connect',
      getDisplayName: name => `Connect(${name})`,
      shouldHandleStateChanges: Boolean(mapStateToProps),
      initMapStateToProps,
      initMapDispatchToProps,
      initMergeProps,
      pure,
      areStatesEqual,
      areOwnPropsEqual,
      areStatePropsEqual,
      areMergedPropsEqual,
      ...extraOptions
    })
  }

}
```
### 3.分析connect传入mapStateToProps后,做了什么处理

```js

/**
 * mapStateToProps所做的处理
 */
const initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps')

/**
 * mapStateToPropsFactories是一个数组
 * 依次调用factories中的方法，入参arg，即mapStateToProps，return结果，如果没有结果就抛出异常
 */
function match(arg, factories, name) {
  for (let i = factories.length - 1; i >= 0; i--) {
    const result = factories[i](arg)
    if (result) {
      return result
    }
  }

  return (dispatch, options) => {
    throw new Error(`Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`)
  }
}

/**
 * mapStateToPropsFactories里面的方法又是这两个
 * 这里我们传入的mapStateToProps是一个function
 */
export function whenMapStateToPropsIsFunction(mapStateToProps) {
  return (typeof mapStateToProps === 'function')
    ? wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps')
    : undefined
}

export function whenMapStateToPropsIsMissing(mapStateToProps) {
  return (!mapStateToProps)
    ? wrapMapToPropsConstant(() => ({}))
    : undefined
}

/**
 * 所以我们会调用wrapMapToPropsFunc
 * 入参
 * function, 'mapStateToProps'
 */
export function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, { displayName }) {
    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps
        ? proxy.mapToProps(stateOrDispatch, ownProps)
        : proxy.mapToProps(stateOrDispatch)
    }

    // allow detectFactoryAndVerify to get ownProps
    proxy.dependsOnOwnProps = true

    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps)
      let props = proxy(stateOrDispatch, ownProps)

      if (typeof props === 'function') {
        proxy.mapToProps = props
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props)
        props = proxy(stateOrDispatch, ownProps)
      }

      if (process.env.NODE_ENV !== 'production') 
        verifyPlainObject(props, displayName, methodName)

      return props
    }

    return proxy
  }
}

/**
 * 可见,返回了一个方法initProxySelector,
 * 回到开始,同理其他结果返回
 */
const initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps')
const initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps')
const initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps')

// 即为:
const initMapStateToProps     = function initProxySelector(dispatch, { displayName }){/*....*/}
const initMapDispatchToProps  = function initProxySelector(dispatch, { displayName }){/*....*/}
const initMergeProps          = function defaultMergeProps(stateProps, dispatchProps, ownProps){/*....*/}

/**
 * 然后开始调用connect()(Todo)
 * selectorFactory 就是 Todo
 */
return connectHOC(selectorFactory, {/* 传入一些参数 */})





/**
 * 我们来看看connectAdvanced (connectHOC) 方法
 * connect(...)(Todo)
 * 其实就是 connectAdvanced(Todo)
 * 返回 wrapWithConnect(WrappedComponent){ return hoistStatics(...) }
 */
import hoistStatics from 'hoist-non-react-statics'

export default function connectAdvanced(selectorFactory) {
  return function wrapWithConnect(WrappedComponent) {
    class Connect extends Component {
      constructor(props, context) {
        super(props, context)
      }
      render() {
        /*...*/
      }
    }
    return hoistStatics(Connect, WrappedComponent)
  }
}

/**
 * 我们来看看wrapWithConnect(..Todo..)里面的Connect组件
 */
class Connect extends Component {
  constructor(props, context) {
    super(props, context)

    this.state = {}

    //  storeKey = store
    this.store = props[storeKey] || context[storeKey]
    //  判断store确实存在
    this.propsMode = Boolean(props[storeKey])

    //  暂时不知道确切做什么,但是它绑定了this,这样即使在别的组件中调用this,也会指向Connect
    this.setWrappedInstance = this.setWrappedInstance.bind(this)

    this.initSelector()
    this.initSubscription()
  }

  componentDidMount() {
    if (!shouldHandleStateChanges) 
      return

    this.subscription.trySubscribe()
    this.selector.run(this.props)
    if (this.selector.shouldComponentUpdate) 
      this.forceUpdate()
  }

}





/**
 * addExtraProps()
 * 添加额外的props
 */
addExtraProps(props) {
  const withExtras = { ...props }
  if (renderCountProp) withExtras[renderCountProp] = this.renderCount++;// render 调用次数
  if (this.propsMode && this.subscription) withExtras[subscriptionKey] = this.subscription

  return withExtras
}


/**
    initSelector()
    初始化selector
    Selector，选择器，根据redux store state和组件的自身props，
    计算出将注入该组件的新props，并缓存新props，之后再次执行选择器时通过对比得出的props，
    决定是否需要更新组件，若props变更则更新组件，否则不更新。
 */
initSelector() {
  // 使用selector工厂函数创建一个selector
  const sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions)
  // 连接组件的selector和redux store state
  this.selector = makeSelectorStateful(sourceSelector, this.store)
  // 执行组件的selector函数
  this.selector.run(this.props)
}



/**
    selectorFactory()
    传入dispatch
 */
export default function finalPropsSelectorFactory(dispatch, {
  initMapStateToProps,
  initMapDispatchToProps,
  initMergeProps,
  ...options
}) {
  const mapStateToProps = initMapStateToProps(dispatch, options)
  const mapDispatchToProps = initMapDispatchToProps(dispatch, options)
  const mergeProps = initMergeProps(dispatch, options)

  if (process.env.NODE_ENV !== 'production') {
    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName)
  }

  const selectorFactory = options.pure
    ? pureFinalPropsSelectorFactory
    : impureFinalPropsSelectorFactory

  return selectorFactory(
    mapStateToProps,
    mapDispatchToProps,
    mergeProps,
    dispatch,
    options
  )
}




/**
    makeSelectorStateful()
 */
function makeSelectorStateful(sourceSelector, store) {
  // 返回selector追踪对象，追踪传入的selector（sourceSelector）返回的结果
  const selector = {
    // 执行组件的selector函数
    run: function runComponentSelector(props) {
      try {
        // 根据store state和组件props执行传入的selector函数，计算得到nextProps
        const nextProps = sourceSelector(store.getState(), props)
        // 比较nextProps和缓存的props;
        // false，则更新所缓存的props并标记selector需要更新
        if (nextProps !== selector.props || selector.error) {
          selector.shouldComponentUpdate = true // 标记需要更新
          selector.props = nextProps  // 缓存props
          selector.error = null
        }
      } catch (error) {
        selector.shouldComponentUpdate = true
        selector.error = error
      }
    }
  }
  // 返回selector追踪对象
  return selector
}




/**
    initSubscription()
    初始化监听／订阅redux store state：
 */
initSubscription() {
  if (!shouldHandleStateChanges) 
    return
  const parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey]
  this.subscription = new Subscription(this.store, parentSub, this.onStateChange.bind(this))
  this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription)
}


/**
    订阅类实现
    初始化监听／订阅redux store state
    组件订阅store使用的订阅发布器实现
 */


export default class Subscription {
  constructor(store, parentSub, onStateChange) {
    this.store = store                  //store
    this.parentSub = parentSub          //订阅内容
    this.onStateChange = onStateChange  //订阅内容变更后的回调函数
    this.unsubscribe = null
    this.listeners = nullListeners      //订阅记录数组
  }

  addNestedSub(listener) {
    this.trySubscribe()
    return this.listeners.subscribe(listener)
  }

  notifyNestedSubs() {
    //发布
    this.listeners.notify()
  }

  isSubscribed() {
    return Boolean(this.unsubscribe)
  }

  //订阅
  trySubscribe() {
    //如果有订阅
    if (!this.unsubscribe) {
      this.unsubscribe = this.parentSub
        //如果传递了发布订阅器则使用订阅器方法订阅
        //否则就使用store方法
        ? this.parentSub.addNestedSub(this.onStateChange)
        : this.store.subscribe(this.onStateChange)

      //创建一个订阅合集对象
      //{ notify:fun(), subscribe:fun(), notify:fun(), get:func() }
      this.listeners = createListenerCollection()
    }
  }

  tryUnsubscribe() {
    if (this.unsubscribe) {
      this.unsubscribe()
      this.unsubscribe = null
      this.listeners.clear()
      this.listeners = nullListeners
    }
  }
}




/**
    看看这个订阅合集对象
    createListenerCollection
 */
const CLEARED = null
const nullListeners = { notify() {} }

function createListenerCollection() {

  let current = []
  let next = []

  return {
    clear() {
      next = CLEARED
      current = CLEARED
    },

    notify() {
      const listeners = current = next
      for (let i = 0; i < listeners.length; i++) {
        listeners[i]()
      }
    },

    get() {
      return next
    },

    subscribe(listener) {
      let isSubscribed = true
      if (next === current) next = current.slice()
      next.push(listener)

      return function unsubscribe() {
        if (!isSubscribed || current === CLEARED) return
        isSubscribed = false

        if (next === current) next = current.slice()
        next.splice(next.indexOf(listener), 1)
      }
    }
  }

}


/**
    我们再回到Connect组件中
    订阅的回调函数
    this.onStateChange.bind(this)
    [这里的this指向了Connect组件]
 */
onStateChange() {
  //执行器执行
  this.selector.run(this.props)
  if (!this.selector.shouldComponentUpdate) {
    //不需要更新则直接发布
    this.notifyNestedSubs()
  } else {
    //需要更新则设置组件的componentDidUpdate方法
    this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate
    // 同时调用setState触发组件更新
    this.setState(dummyState)
  }
}

/**
    componentDidUpdate
 */
notifyNestedSubsOnComponentDidUpdate() {
  //清除组件的componentDidUpdate生命周期方法
  this.componentDidUpdate = undefined
  //发布
  this.notifyNestedSubs()
}


/**
    其他的生命周期方法
 */
getChildContext () {
  // 若存在props传递了store，则需要对其他从context接收store并订阅的后代组件隐藏其对于store的订阅；
  // 否则将父级的订阅器映射传入，给予Connect组件控制发布变化的顺序流
  const subscription = this.propsMode ? null : this.subscription
  return { [subscriptionKey]: subscription || this.context[subscriptionKey] }
}
// 接收到新props
componentWillReceiveProps(nextProps) {
  this.selector.run(nextProps)
}

// 是否需要更新组件
shouldComponentUpdate() {
  return this.selector.shouldComponentUpdate
}

componentWillUnmount() {
  // 重置selector
}













/**
 * 调用了selectorFactory
 * 总之就是调用impureFinalPropsSelectorFactory和pureFinalPropsSelectorFactory
 */
export function impureFinalPropsSelectorFactory(
  mapStateToProps,
  mapDispatchToProps,
  mergeProps,
  dispatch
) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps(
      mapStateToProps(state, ownProps),
      mapDispatchToProps(dispatch, ownProps),
      ownProps
    )
  }
}

export function pureFinalPropsSelectorFactory(
  mapStateToProps,
  mapDispatchToProps,
  mergeProps,
  dispatch,
  { areStatesEqual, areOwnPropsEqual, areStatePropsEqual }
) {
  let hasRunAtLeastOnce = false
  let state
  let ownProps
  let stateProps
  let dispatchProps
  let mergedProps

  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState
    ownProps = firstOwnProps
    stateProps = mapStateToProps(state, ownProps)
    dispatchProps = mapDispatchToProps(dispatch, ownProps)
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
    hasRunAtLeastOnce = true
    return mergedProps
  }

  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps)

    if (mapDispatchToProps.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps(dispatch, ownProps)

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
    return mergedProps
  }

  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps)
      stateProps = mapStateToProps(state, ownProps)

    if (mapDispatchToProps.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps(dispatch, ownProps)

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
    return mergedProps
  }

  function handleNewState() {
    const nextStateProps = mapStateToProps(state, ownProps)
    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps)
    stateProps = nextStateProps
    
    if (statePropsChanged)
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps)

    return mergedProps
  }

  function handleSubsequentCalls(nextState, nextOwnProps) {
    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps)
    const stateChanged = !areStatesEqual(nextState, state)
    state = nextState
    ownProps = nextOwnProps

    if (propsChanged && stateChanged) return handleNewPropsAndNewState()
    if (propsChanged) return handleNewProps()
    if (stateChanged) return handleNewState()
    return mergedProps
  }

  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce
      ? handleSubsequentCalls(nextState, nextOwnProps)
      : handleFirstCall(nextState, nextOwnProps)
  }
}

const selectorFactory = options.pure
    ? pureFinalPropsSelectorFactory
    : impureFinalPropsSelectorFactory

export default function finalPropsSelectorFactory(){
  return selectorFactory(
    mapStateToProps,
    mapDispatchToProps,
    mergeProps,
    dispatch,
    options
  )
}

























```