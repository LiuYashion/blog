# connect流程
这里默认mapStateToProps，mapDispatchToProps都是function
```js
export default connect(
  mapStateToProps,
  mapDispatchToProps
)(Todo)
```

### 1. 调用connect，connect/connect.js
介绍下面结构，用到了解构赋值，是一个科里化函数，={}这个不是多余的，否则当()传空的时候，就会报错
```js
var otherFunction = function(){ console.log('finished') }
export function createConnect( {a = 10}={} ) {
  console.log(arguments)
  return function connect( {pure = true, connectHOC=otherFunction}={} ) {
    return connectHOC()
  }
}

createConnect()()
//  finished
```
其实我们调用的就是：connectHOC()

### 2.分析connect里面的方法
```js
export function createConnect({
  /*  一些准备好的工具函数，在connect中调用  */
  connectHOC = connectAdvanced,
  mapStateToPropsFactories = defaultMapStateToPropsFactories,
  mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories,
  mergePropsFactories = defaultMergePropsFactories,
  selectorFactory = defaultSelectorFactory
} = {}) {

  return function connect(
    mapStateToProps,
    mapDispatchToProps,
    mergeProps,
    /*...*/
  ) {
    
    const initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps')
    const initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps')
    const initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps')

    return connectHOC(selectorFactory, {
      // used in error messages
      methodName: 'connect',
      getDisplayName: name => `Connect(${name})`,
      shouldHandleStateChanges: Boolean(mapStateToProps),
      initMapStateToProps,
      initMapDispatchToProps,
      initMergeProps,
      pure,
      areStatesEqual,
      areOwnPropsEqual,
      areStatePropsEqual,
      areMergedPropsEqual,
      ...extraOptions
    })
  }

}
```
### 3.分析connect传入mapStateToProps后,做了什么处理

```js

/**
 * mapStateToProps所做的处理
 */
const initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps')

/**
 * mapStateToPropsFactories是一个数组
 * 依次调用factories中的方法，入参arg，即mapStateToProps，return结果，如果没有结果就抛出异常
 */
function match(arg, factories, name) {
  for (let i = factories.length - 1; i >= 0; i--) {
    const result = factories[i](arg)
    if (result) {
      return result
    }
  }

  return (dispatch, options) => {
    throw new Error(`Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`)
  }
}

/**
 * mapStateToPropsFactories里面的方法又是这两个
 * 这里我们传入的mapStateToProps是一个function
 */
export function whenMapStateToPropsIsFunction(mapStateToProps) {
  return (typeof mapStateToProps === 'function')
    ? wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps')
    : undefined
}

export function whenMapStateToPropsIsMissing(mapStateToProps) {
  return (!mapStateToProps)
    ? wrapMapToPropsConstant(() => ({}))
    : undefined
}

/**
 * 所以我们会调用wrapMapToPropsFunc
 * 入参
 * function, 'mapStateToProps'
 */
export function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, { displayName }) {
    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps
        ? proxy.mapToProps(stateOrDispatch, ownProps)
        : proxy.mapToProps(stateOrDispatch)
    }

    // allow detectFactoryAndVerify to get ownProps
    proxy.dependsOnOwnProps = true

    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps)
      let props = proxy(stateOrDispatch, ownProps)

      if (typeof props === 'function') {
        proxy.mapToProps = props
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props)
        props = proxy(stateOrDispatch, ownProps)
      }

      if (process.env.NODE_ENV !== 'production') 
        verifyPlainObject(props, displayName, methodName)

      return props
    }

    return proxy
  }
}

/**
 * 可见,返回了一个方法initProxySelector,
 * 回到开始,同理其他结果返回
 */
const initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps')
const initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps')
const initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps')

// 即为:
const initMapStateToProps     = function initProxySelector(dispatch, { displayName }){/*....*/}
const initMapDispatchToProps  = function initProxySelector(dispatch, { displayName }){/*....*/}
const initMergeProps          = function defaultMergeProps(stateProps, dispatchProps, ownProps){/*....*/}

/**
 * 然后开始调用connect()(Todo)
 * selectorFactory 就是 Todo
 */
return connectHOC(selectorFactory, {/* 传入一些参数 */})





/**
 * 我们来看看connectAdvanced (connectHOC) 方法
 * connect(...)(Todo)
 * 其实就是 connectAdvanced(Todo)
 * 返回 wrapWithConnect(WrappedComponent){ return hoistStatics(...) }
 */
import hoistStatics from 'hoist-non-react-statics'

export default function connectAdvanced(selectorFactory) {
  return function wrapWithConnect(WrappedComponent) {
    class Connect extends Component {
      constructor(props, context) {
        super(props, context)
      }
      render() {
        /*...*/
      }
    }
    return hoistStatics(Connect, WrappedComponent)
  }
}

/**
 * 我们来看看wrapWithConnect(..Todo..)里面的Connect组件
 */
class Connect extends Component {
  constructor(props, context) {
    super(props, context)

    this.state = {}

    //  storeKey = store
    this.store = props[storeKey] || context[storeKey]
    //  判断store确实存在
    this.propsMode = Boolean(props[storeKey])

    //  暂时不知道确切做什么,但是它绑定了this,这样即使在别的组件中调用this,也会指向Connect
    this.setWrappedInstance = this.setWrappedInstance.bind(this)

    this.initSelector()
    this.initSubscription()
  }

  initSelector() {
    const sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions)
    this.selector = makeSelectorStateful(sourceSelector, this.store)
    this.selector.run(this.props)
  }

}

/**
 * 调用了selectorFactory
 * 总之就是调用impureFinalPropsSelectorFactory和pureFinalPropsSelectorFactory
 */
export function impureFinalPropsSelectorFactory(
  mapStateToProps,
  mapDispatchToProps,
  mergeProps,
  dispatch
) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps(
      mapStateToProps(state, ownProps),
      mapDispatchToProps(dispatch, ownProps),
      ownProps
    )
  }
}

export function pureFinalPropsSelectorFactory(
  mapStateToProps,
  mapDispatchToProps,
  mergeProps,
  dispatch,
  { areStatesEqual, areOwnPropsEqual, areStatePropsEqual }
) {
  let hasRunAtLeastOnce = false
  let state
  let ownProps
  let stateProps
  let dispatchProps
  let mergedProps

  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState
    ownProps = firstOwnProps
    stateProps = mapStateToProps(state, ownProps)
    dispatchProps = mapDispatchToProps(dispatch, ownProps)
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
    hasRunAtLeastOnce = true
    return mergedProps
  }

  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps)

    if (mapDispatchToProps.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps(dispatch, ownProps)

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
    return mergedProps
  }

  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps)
      stateProps = mapStateToProps(state, ownProps)

    if (mapDispatchToProps.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps(dispatch, ownProps)

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
    return mergedProps
  }

  function handleNewState() {
    const nextStateProps = mapStateToProps(state, ownProps)
    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps)
    stateProps = nextStateProps
    
    if (statePropsChanged)
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps)

    return mergedProps
  }

  function handleSubsequentCalls(nextState, nextOwnProps) {
    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps)
    const stateChanged = !areStatesEqual(nextState, state)
    state = nextState
    ownProps = nextOwnProps

    if (propsChanged && stateChanged) return handleNewPropsAndNewState()
    if (propsChanged) return handleNewProps()
    if (stateChanged) return handleNewState()
    return mergedProps
  }

  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce
      ? handleSubsequentCalls(nextState, nextOwnProps)
      : handleFirstCall(nextState, nextOwnProps)
  }
}

const selectorFactory = options.pure
    ? pureFinalPropsSelectorFactory
    : impureFinalPropsSelectorFactory

export default function finalPropsSelectorFactory(){
  return selectorFactory(
    mapStateToProps,
    mapDispatchToProps,
    mergeProps,
    dispatch,
    options
  )
}

























```