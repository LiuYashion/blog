# 引用类型
javascript除了基本类型(string,number,boolean,null,undefined,symbol)，就是引用类型了。我们也可以成为对象，对象是一个属性和方法的集合。而属性又可以分为基本类型和引用类型。

## Object引用类型
创建一个对象可用2种方式：new构造函数，对象字面量
```js
var person = new Object()
var person = {}
```

## Array引用类型
创建一个对象可用2种方式：new 构造函数，数组字面量
```js
var colors = new Array('red', 'brown')
var colors = ['red', 'brown']
```

### array.length
- length：不是只读的，可以指定数组长度，从末尾移除或添加数组
```js
var array = [1, 2, 3]
array[99] = 100
array.length // 100，然而[3]~[98]其实都是undefined
```


### Array.isArray()
可以通过Array.isArray()来判断是否为数组

```js
// instanceof用于判断 A 是否为 B 的实例
function Foo(){} 
var foo = new Foo(); 

console.log(foo instanceof Foo) // true
console.log(Number instanceof Function)       //  true 
console.log(Function instanceof Function)   //  true 
console.log(Function instanceof Object)     //  true 
```

### array.push(),array.pop() 
栈方法

### array.unshift(),array.shift() 
队方法

### array.reverse(),array.sort() 
排序方法
```js
// return true升序
var arr = [3, 6, 9, 10, 1]
arr.sort(function(item1, item2){
  return item1- item2
})
console.log(arr) // [1, 3, 6, 9, 10]
```

### array.concat(args)
数组拼接
```javascript
var arr  = [1, 2, 3]
var arr_ = arr.concat(4, [1, [2, 3]])
// arr  [1, 2, 3]
// arr_ [1, 2, 3, 4, 1, [2, 3]]
```

### array.slice(start, end)
按开始，结束截取（原数组不变）
```js
var arr  = [1, 2, 3, 4, 5]
var arr_ = arr.slice(1, 4)
var ar__ = arr.slice(1)
// arr  [1, 2, 3, 4, 5]
// arr_ [2, 3, 4]
// ar__ [2, 3, 4, 5]
```

### array.splice(start, length, insert)；
按开始，长度截取（原数组改变）
```js
// length不传，默认截取至末尾
var arr  = [1, 2, 3, 4, 5]
var arr_ = arr.splice(1, 2)
// arr  [1, 4, 5]
// arr_ [2, 3]


// 使用适当参数能够实现插入效果
var arr  = [1, 2, 3]
var arr_ = arr.splice(1, 0, 5, 6)
console.log(arr, arr_)
// arr  [1, 5, 6, 2, 3]
// arr_ []


// 使用适当参数能够实现替换效果
var arr  = [1, 2, 3]
var arr_ = arr.splice(1, 2, 5, 6)
console.log(arr, arr_)
// arr  [1, 5, 6]
// arr_ [2, 3]
```


### array.indexOf(value) | array.lastIndexOf(value)
检索value在数组中的位置，一个是顺序查找，一个是逆序查找


## array迭代
这些方法都不改变原数组

### array.every((item, index, array)=>{})
每个function返回true，结果才为true

### array.some((item, index, array)=>{})
function返回包含true，结果就为true

### array.filter((item, index, array)=>{})
返回return为true的item组成的新数组

### array.forEach((item, index, array)=>{})
遍历每个item，没有返回值，也无法break

### array.map((item, index, array)=>{})
遍历每个item，return的值组成一个新数组

```js
var arr = [1, 2, 3, 4, 5]
var everyResult = arr.filter((item, index, array)=>{
  return item%2
})
console.log(arr)          //  [1, 2, 3, 4, 5]
console.log(everyResult)  //  [1, 3, 5]
```


## array递归

### values.reduce((prev, item, index, array)=>{})
在最前面加了一个参数，表示上一次调用的结果。
```javascript
var values = [1, 2, 3]
var sum = values.reduce(function(prev, curr, index, array){
  return (prev + curr)*2
})
console.log(sum) // 18
// ((1+2)*2+3)*2
```

### values.reduceRight((prev, item, index, array)=>{})
和上面的区别就是从右往左reduce



## Function引用类型
创建函数的方法：函数表达式，函数声明

下面两种申明方法没有明显差别（在作用域提升上，var的会优先声明，第二种会申明，同时完成初始化)
```js
var sum = function(){}
function sum(){}
```

### 函数内部属性
其实就是作用域的活动对象
```js
var funtion = function(){
  arguments               //  类数组对象(有length和索引访问)，里面存有函数传入的所有参数
  arguments.callee        //  指向拥有这个arguments对象的函数，用于回调自身时解除耦合性。
  arguments.callee.caller //  保存的调用当前函数的函数的引用
  this                    //  this指向函数内部的环境对象，函数名只是个指针
}
```

### 函数的属性
```js
var expFun = function(){}
expFun.length    //  参数个数
expFun.prototype //  保存自身实例方法的所在，该属性无法被枚举
```

### 函数的方法：3个都是给函数绑定上下文
```javascript
var expFun = function(){}
expFun.call(this, num1, num2)
expFun.apply(this, [num1, num2])
expFun.bind(this)
```

# 基本包装类型
基本类型调用方法

```js
var str1 = "string~"
var str2 = str1.substring(2)

//这里基本数据类型没有sbustring方法，所以代码执行时，相当于创建了一个临时对象

var str1 = new String(str1)
var str2 = str1.substring(2)
str1 = null
```


> 不过一般不建议使用基本包装类型创建对象
> 这会让人不知道在操作基本数据类型还是object(因为typeof的结果都是object)
> 示例如下
> 并且基本包装类型转换为bool值都为true。
> 要注意的是，使用new创建的都是object
> 使用转型函数（Number(10)）创建的基本数据类型不变

```js
var value = "25"

var number1 = Number(value)
var number2 = new Number(value) 
// typeof number1   number
// typeof number2   object
```

## String引用类型

### string索引方法
```js
var str = 'Hello World'
str.charAt(1) // e
```

### string操作方法
```js
var str = '   Hello World'
str.concat('!!!') // '   Hello World!!!'
str.trim()        // 'Hello World'
str.toLowerCase() // 'hello world'
str.toUpperCase() // 'HELLO WORLD'
```



### string创建方法
```js
var str = 'Hello World'
str.slice(1, 2) //  e
str.slice(1,-2) //  ello Wor

str.substr(1, 2) //  el
str.substr(-3,2) //  rl
//如果是负数，start加上字符串长度, end+1变成0

str.substring(1, 4) // ell
str.substring(1,-4) // H
//如果是负数，变成0，总是小的靠前
```

    
### string位置方法
```js
var str = 'Hello World'
str.indexOf(value, from)
str.lastIndexOf(value, from)
```


### string匹配方法
```js
var str = 'Hello World'
str.search(/orld/)          // 7
str.replace(/old/, /new/)   // 只替换一个
str.replace(/old/g, /new/)  // 全局替换
str.split('o', 2)           // ["Hell", " W"]
```


## Number引用类型

### number舍入方法
```js
var num = Number(10.3528423)
num.toFixed(3)      //  10.353  四舍五入到小数点3位
num.toPrecision(3)  //  10.4    四舍五入到3位有效数字
```



## *单体内置对象*

### URL编码方法
```js
// 字符串作为url进行编码，只编码query和path部分
encodeURI()         
decodeURI()

//字符串作为url进行编码，整个字符串都会被编码
encodeURIComponent()
decodeURIComponent()
```

### eval(string)
能够把传入的string当做js代码执行，需要严格控制。

## Global对象
取决于js的运行环境，宿主环境提供的一个终极全局对象

## Window对象
web浏览器用来当做全局对象处理的对象，目前浏览器端，window对象除了扮演了global对象的角色之外，还承担了很承担了很多别的任务

## Math对象
```js
Math.max()
Math.min()
Math.ceil()   //  进位
Math.round()  //  四舍五入
Math.floor()  //  舍位
Math.random() //  (0, 1)，

var values = [3, 45, 12, 456]


Math.max(-3, 5, 8, 100)       // 100
Math.max(...values)           // 456
Math.max.apply(Math, values)  // 456
```
