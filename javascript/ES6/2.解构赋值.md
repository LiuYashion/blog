
## 解构赋值
允许按照一定的模式,从数组和对象中提取值.然后对变量进行赋值,这种做法成为解构赋值

```js
let [head, ...tail] = [1, 2, 3, 4]
//  head  1
//  tail  [2, 3, 4]

let [ , , third] = ["foo", "bar", "baz"];
//  third "baz"

let [x, y, ...z] = ['a'];
//  x "a"
//  y undefined
//  z []

let [x, y, ...z] = ['a'];


var {x: y=3} = {};
//  y 3

var {x: y=3} = {x: 5};
//  y 5
```

## 解构赋值作用

### 1.交换值
```js
let x = 1;
let y = 2;
[x, y] = [y, x];
```

### 2.方便取值,提取json数据
```js
function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();

function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar:key } = example();
// foo, key - 1, 2
```


### 3.函数参数定义
```js
function f([x, y, z]) { 
  // 参数是一组有次序的值
}
f([1, 2, 3]);


function f({x, y, z}) { 
  // 参数是一组无次序的值
}
f({z: 3, y: 2, x: 1});
```

### 4.函数默认值
```js
function lyxFetch(url, {
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
}) {
  // ... do stuff
};
```




## 这是react-redux中的一段代码
新建并附上了默认值
```js
function createConnect({
  connectHOC = connectAdvanced,
  mapStateToPropsFactories = defaultMapStateToPropsFactories,
} = {}){}

```

## 函数传参
下面例子中,方法中定义了默认值.调用时传入了参数,参数被解构,没用赋的key被保留在对象中
```js

function connect(propsA, {
  pureProp = true,
  ...extraOptions
} = {}){
  console.log(1, pureProp)      // unknow
  console.log(2, extraOptions)  // {extTag: "tag"}
}

connect('Liu', {
  pureProp: 'unknow',
  extTag: 'tag'
})


/**
  通过上面的结果可以看出, arguments的结构很好理解, 即解构赋值并覆盖掉默认值
  connect参数这种写法, [在设置了默认值的同时, 允许传入参数覆盖掉默认值]
  注意一下extraOptions里面使用到的key被提取了出来, 只剩下了extTag

```