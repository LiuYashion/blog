


## 2.2 Function.prototype
Function.prototype是个例外，它是原型对象，却又是函数对象，作为一个函数对象，它又没有prototype属性。

其实Person.prototype就是Person的一个实例对象。相当于在person创建的时候，自动创建了一个它的实例，并且把这个实例赋值给了prototype。



# 3. 原型链
原型链是将构造函数原型串联起来的一个链表。


原型对象有constructor指向构造函数，
实例对象有__proto__指向原型对象

如果让原型对象等于另一个类的实例对象，此时的原型对象A将包含__protp__指向另一个原型对象B，原型对象B有constructor指向构造函数。如果B的原型对象是构造函数C的实例呢，如此下来就构成了原型链。即prototype链接起来的一个链表。
```js
function Super(){}
Super.prototype.getName = function(){
  return this.name
}

function Sub(){}
Sub.prototype = new Super()

var subInstance = new Sub()
```





# X. Problem

## X.1 写一个原型继承
```js
function Super(){}
Super.prototype.getName = function(){
  return this.name
}

function Sub(){}
Sub.prototype = new Super()

var subInstance = new Sub()
```


## X.2 new过程
先new一个对象，更改对象的原型链指向，然后传入对象为上下文调用构造函数
```js
/** 执行下面代码 */
var person1 = new Person('Clay', 18)

/** 实际上执行的是 */
var person1 = new Object();  
person1.__proto__ = Person.prototype;
Person.call(person1, 'Clay', 18);
```

